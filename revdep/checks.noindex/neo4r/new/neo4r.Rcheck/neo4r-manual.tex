\nonstopmode{}
\documentclass[a4paper]{book}
\usepackage[times,inconsolata,hyper]{Rd}
\usepackage{makeidx}
\usepackage[utf8]{inputenc} % @SET ENCODING@
% \usepackage{graphicx} % @USE GRAPHICX@
\makeindex{}
\begin{document}
\chapter*{}
\begin{center}
{\textbf{\huge Package `neo4r'}}
\par\bigskip{\large \today}
\end{center}
\begin{description}
\raggedright{}
\inputencoding{utf8}
\item[Title]\AsIs{A 'Neo4J' Driver}
\item[Version]\AsIs{0.1.1}
\item[Description]\AsIs{A Modern and Flexible 'Neo4J' Driver, allowing you to query
data on a 'Neo4J' server and handle the results in R. It's modern in
the sense it provides a driver
that can be easily integrated in a data analysis workflow, especially by
providing an API working smoothly with other data analysis and graph
packages. It's flexible in the  way it returns the results, by
trying to stay as close as
possible to the way 'Neo4J' returns data. That way, you have the control
over the way you will compute the results. At the same time, the result
is not too complex, so that the ``heavy lifting'' of data wrangling is not
left to the user.}
\item[License]\AsIs{MIT + file LICENSE}
\item[URL]\AsIs{}\url{https://github.com/neo4j-rstats/neo4r}\AsIs{}
\item[BugReports]\AsIs{}\url{https://github.com/neo4j-rstats/neo4r/issues}\AsIs{}
\item[Imports]\AsIs{attempt, data.table, glue, httr, igraph, jsonlite, magrittr,
purrr, R6, rlang, rstudioapi, shiny, tibble, tidyr, tidyselect,
utils}
\item[Encoding]\AsIs{UTF-8}
\item[LazyData]\AsIs{true}
\item[RoxygenNote]\AsIs{6.1.0}
\item[NeedsCompilation]\AsIs{no}
\item[Author]\AsIs{Colin Fay [cre, aut] (<https://orcid.org/0000-0001-7343-1846>),
ThinkR [cph],
Neo4J [spn]}
\item[Maintainer]\AsIs{Colin Fay }\email{contact@colinfay.me}\AsIs{}
\item[Repository]\AsIs{CRAN}
\item[Date/Publication]\AsIs{2019-02-15 22:20:03 UTC}
\end{description}
\Rdcontents{\R{} topics documented:}
\inputencoding{utf8}
\HeaderA{call\_neo4j}{Call Neo4J API}{call.Rul.neo4j}
%
\begin{Description}\relax
Call Neo4J API
\end{Description}
%
\begin{Usage}
\begin{verbatim}
call_neo4j(query, con, type = c("row", "graph"), output = c("r",
  "json"), include_stats = FALSE, include_meta = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{query}] The cypher query

\item[\code{con}] A NEO4JAPI connection object

\item[\code{type}] Return the result as row or as graph

\item[\code{output}] Use "json" if you want the output to be printed as JSON

\item[\code{include\_stats}] tShould the stats about the transaction be included?

\item[\code{include\_meta}] tShould the stats about the transaction be included?
\end{ldescription}
\end{Arguments}
%
\begin{Value}
the result from the Neo4J Call
\end{Value}
\inputencoding{utf8}
\HeaderA{extract\_nodes}{Extract nodes or relationships}{extract.Rul.nodes}
\aliasA{extract\_relationships}{extract\_nodes}{extract.Rul.relationships}
%
\begin{Description}\relax
Extract nodes or relationships
\end{Description}
%
\begin{Usage}
\begin{verbatim}
extract_nodes(x)

extract_relationships(x)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] a result from Neo4J
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a tibble
\end{Value}
\inputencoding{utf8}
\HeaderA{launch\_con\_pane}{Launch Neo4J Connection Pane}{launch.Rul.con.Rul.pane}
%
\begin{Description}\relax
Launch Neo4J Connection Pane
\end{Description}
%
\begin{Usage}
\begin{verbatim}
launch_con_pane(con)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{con}] a connection object
\end{ldescription}
\end{Arguments}
%
\begin{Value}
an opened Connection Pane
\end{Value}
\inputencoding{utf8}
\HeaderA{load\_csv}{Load a CSV to Neo4J}{load.Rul.csv}
%
\begin{Description}\relax
Load a CSV to Neo4J
\end{Description}
%
\begin{Usage}
\begin{verbatim}
load_csv(on_load = "", con, url, header = TRUE,
  periodic_commit = 1000, as = "csv", type = c("row", "graph"),
  output = c("r", "json"), include_stats = TRUE,
  include_meta = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{on\_load}] the code to execute on load

\item[\code{con}] A NEO4JAPI connection object

\item[\code{url}] the url of the csv

\item[\code{header}] does the csv have a header?

\item[\code{periodic\_commit}] the PERIODIC COMMIT cypher arg

\item[\code{as}] the AS cypher arg

\item[\code{type}] Return the result as row or as graph

\item[\code{output}] Use "json" if you want the output to be printed as JSON

\item[\code{include\_stats}] tShould the stats about the transaction be included?

\item[\code{include\_meta}] tShould the stats about the transaction be included?
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a csv loaded to Neo4J
\end{Value}
\inputencoding{utf8}
\HeaderA{neo4j\_api}{A Neo4J Connexion}{neo4j.Rul.api}
\keyword{datasets}{neo4j\_api}
%
\begin{Description}\relax
A Neo4J Connexion
\end{Description}
%
\begin{Usage}
\begin{verbatim}
neo4j_api
\end{verbatim}
\end{Usage}
%
\begin{Format}
An object of class \code{R6ClassGenerator} of length 24.
\end{Format}
%
\begin{Value}
A Neo4J Connexion
\end{Value}
%
\begin{Section}{Methods}

\begin{description}

\item[\code{access}] list url, user and password
\item[\code{ping}] test your connexion
\item[\code{version}] Neo4J version
\item[\code{get}] Get a list of either relationship, labels, 
\item[\code{get}] Get a list of either relationship, labels, 
\item[\code{get}] Get a list of either relationship, labels, 
\item[\code{get}] Get a list of either relationship, labels, 
\item[\code{get}] Get a list of either relationship, labels, 

\end{description}

\end{Section}
%
\begin{Section}{Data}

\begin{description}

\item[\code{url}] list url, user and password
\item[\code{user}] test your connexion

\end{description}

\end{Section}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
con <- neo4j_api$new(url = "http://localhost:7474", user = "neo4j", password = "password")

## End(Not run)


\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{read\_cypher}{Read a cypher file}{read.Rul.cypher}
%
\begin{Description}\relax
Read a cypher file
\end{Description}
%
\begin{Usage}
\begin{verbatim}
read_cypher(file)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{file}] the path to the cypher file
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a tibble with the queries
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
read_cypher("random/create.cypher")

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{send\_cypher}{Send a cypher file to be executed}{send.Rul.cypher}
%
\begin{Description}\relax
Send a cypher file to be executed
\end{Description}
%
\begin{Usage}
\begin{verbatim}
send_cypher(path, con, type = c("row", "graph"), output = c("r",
  "json"), include_stats = TRUE, meta = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{path}] the path to the cypher file

\item[\code{con}] a connexion object created with neo4j\_api\$new()

\item[\code{type}] the type of the format to query for (row or graph)

\item[\code{output}] the printing method (r or json)

\item[\code{include\_stats}] whether of not to include stats

\item[\code{meta}] whether of not to include meta info
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a cypher call
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
send_cypher("random/create.cypher")
path <- "data-raw/constraints.cypher"

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{unnest\_graph}{Unnest both relationships and nodes}{unnest.Rul.graph}
%
\begin{Description}\relax
Unnest both relationships and nodes
\end{Description}
%
\begin{Usage}
\begin{verbatim}
unnest_graph(res)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{res}] an api graph result
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a list of two unnested data.frames
\end{Value}
\inputencoding{utf8}
\HeaderA{unnest\_nodes}{Unnest a node data.frame}{unnest.Rul.nodes}
%
\begin{Description}\relax
Unnest a node data.frame
\end{Description}
%
\begin{Usage}
\begin{verbatim}
unnest_nodes(nodes_tbl, what = c("all", "label", "properties"))
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{nodes\_tbl}] the node table

\item[\code{what}] what to unnest
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a new dataframe
\end{Value}
\inputencoding{utf8}
\HeaderA{unnest\_relationships}{Unnest a Relationships table}{unnest.Rul.relationships}
%
\begin{Description}\relax
Unnest a Relationships table
\end{Description}
%
\begin{Usage}
\begin{verbatim}
unnest_relationships(relationships_tbl)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{relationships\_tbl}] a relationship table
\end{ldescription}
\end{Arguments}
%
\begin{Value}
an unnested table
\end{Value}
%
\begin{Note}\relax
Please note that the properties will be converted to character if the class
is not unique.
\end{Note}
\inputencoding{utf8}
\HeaderA{vec\_to\_cypher}{Turn a named vector into a cypher list}{vec.Rul.to.Rul.cypher}
\aliasA{vec\_to\_cypher\_with\_var}{vec\_to\_cypher}{vec.Rul.to.Rul.cypher.Rul.with.Rul.var}
%
\begin{Description}\relax
`vec\_to\_cypher()` creates a list, and `vec\_to\_cypher\_with\_var()`
creates a cypher call starting with a variable.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
vec_to_cypher(vec, label)

vec_to_cypher_with_var(vec, label, variable)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{vec}] the vector

\item[\code{label}] the label of each vector

\item[\code{variable}] the variable to use (for `vec\_to\_cypher()`)
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
This function can be used with small vectors you want to send
to the server. It can for example be used this way :
```
paste("MERGE", vec\_to\_cypher(iris[1, 1:3], "Species"))
```
to create a cypher call.
\end{Details}
%
\begin{Value}
a character vector
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}

vec_to_cypher(iris[1, 1:3], "Species")
vec_to_cypher_with_var(iris[1, 1:3], "Species", a)
\end{ExampleCode}
\end{Examples}
\printindex{}
\end{document}
